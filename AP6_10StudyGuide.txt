APLabs_06-10: Study Guide

1: E
2: C
3: E
4: A
5: C
6: C
7: B
8: A
9: B
10: B
11: B
12: E
13: C
14: B
15: D

1. int[] arr=new int[4] //creates an arra with 4 positions, filled with zeros by default

2.
Find index of negative integer from arr[0] to arr[n-1]

int i = 0;
while(arr[i] >= 0)
   i++;
location = i;
//Runs as long as arr contains at least 1 non-negative integer
or else i will keep increasing until it exceeds n-1

3.
int sum = arr[0], i = 0;
while(i < arr.length)
{
   i++; //should be put second
   sum += arr[i];
}
//Intent: sum elements arr[0] to arr[arr.length-1]
However, when i has the value arr.length-1, it is incremented to arr.length in the loop, 
so the statement sum += arr[i] uses arr[arr.length], which is out of range. 

5.
for(int i = 2; i <= k; i++)
   if(arr[i] < someValue)
       System.out.print("SMALL");
//There are k-1 iterations
//if it was i<k, there would be k-2 iterations


6. 
int[] arr = {1, 2, 3, 4};
doSomething(arr);
System.out.print(arr[1] + " ");
System.out.print(arr[3]);
//only printing out pos 1 and 3
			. . . 
public void doSomething(int[] list)
{
   int[] b = list; //<-{1,2,3,4}

   for(int i = 0; i < b.length; i++)
       b[i] = i;
//pos 0=0, pos 1=1, pos 2=2, pos3=3
}
answer: 1 3

7.
int min = arr[0];
int i = 1;

while (i < n) //range: arr[0-(n-1)]; don't want i to equal n
{
   if(arr[i] < min)
       min = arr[i];
   i++;
}

//arr[1] is not tested. 
When i has a value of n-1, incrementing i will lead to an out-of-range error for the if(arr[i] < min) test. 


8.
public static boolean match(int[] v, int[] w, int N, int M)
{
   int vIndex = 0, wIndex = 0;
   while (vIndex < N && wIndex < M)
   {
       if(v[vIndex] == w[wIndex])
           return true; //exits the method; assume that this hasn't happened yet
       else if(v[vIndex] < w[wIndex]) //tested that v[vIndex-1]==w[wIndex-1] isn't true in the prev loop
           vIndex++;
       else wIndex++; //goes up to vIndex <= N and wIndex <= M
   }
   return false;
}
//Assuming that the method has not been exited, which assertion is true at the 
end of every execution of the while loop? 
//V[0] .. v[vIndex-1] and w[0] .. w[wIndex-1] contain no common value, vIndex <= N and wIndex <= M. 

11.
public void stringRecur(String s)
{
   if(s.length() < 15)
       System.out.println(s);
   stringRecur(s + "*"); //calls itself again irrespective of the length of s (run-time error)
}
//Will terminate without error for no string inputs


12.
public int result(int n)
{
   if(n == 1)
       return 2;
   else
       return 2 * result(n - 1);
}

//res(5)
= 2*(2*(2*(2*(result(1)))))

2*res(4)= 32
2*res(3)= 16
2*res(2)= 2*4= 8 
2*res(1)--> 2*2= 4
res(1)=2

13. //For result(n) there will be (n-1) recursive calls before res(1), for a total of n method calls

14.
//mystery(3, 2, 6)
= 6 + (6( + mystery(1, 2, 6)) (base case)

6+mystery(2,2,6) 6+8= 14
6+mystery(1,2,6)--> 6+2=8

15. 
f(6,2)
f(4,2)
f(2,2) (base case)
return 2

